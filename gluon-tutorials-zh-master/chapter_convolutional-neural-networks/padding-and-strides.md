# 填充和步幅

在同样形状的输入和核参数下，我们可以通过调节卷基层的填充和步幅来改变输出大小。这一节我们将解释这两个参数。

回忆上一节我们使用的例子，使用`(3, 3)`形状的输入和`(2, 2)`形状的核下我们可以得到`(2, 2)`形状的输出。输出在高和宽上均比输入小1。一般来说，假设输入形状是$n_h\times n_w$，核形状是$k_h\times k_w$，那么输出形状将会是$(n_h-k_h+1) \times (n_h-k_w+1)$。


## 填充

一个改变输出形状的做法是在输入的四周填充元素，其值通常设成0。下图里我们在输入的左边和上边填充了0使得形状变成了`(4, 4)`，从而导致输出形状增加到`(3, 3)`。

![在输入的左边和上边填充了0的二维相关计算。](../img/conv_pad.svg)

一般来说，如果我们在高上填充了$p_h$，在宽上填充了$p_w$，那么输出形状将会是$(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)$.

在卷积神经网络里，我们经常会对输入进行填充来使得输出跟它有一样的高和宽。这样在推测网络中，尤其是深层网络，每个层的输出大小时更加容易。就是说我们会设置$p_h=k_h-1$和$p_w=k_w-1$。如果$k_h$是奇数，我们在输入的上下分别填充$p_h/2$行。如果其是偶数，一种可能是上面填充$\lceil p_h/2\rceil$行，而下面填充$\lfloor p_h/2\rfloor$行。

目前的绝大部分卷积神经网络使用奇数高宽的核，例如1，3，5，和7。所以填充通常是对称的，而且我们知道输出$Y[i,j]$是由输入以$X[i,j]$为中心的区域同核进行相关计算得来。

下面例子里我们创建一个有形状为`(3, 3)`的核的二维卷积层，其中在高和宽的两侧分别填充1。然后构造一个`(8, 8)`的输入，我们会发现输出的高宽也是`(8, 8)`.

```{.python .input  n=1}
from mxnet import nd
from mxnet.gluon import nn

# 定义一个便利函数来计算卷积层。它初始化卷积层权重，并对输入和输出做相应的升维和降维。
def comp_conv2d(conv2d, X):
    conv2d.initialize()
    X = X.reshape((1,1,)+X.shape)
    Y = conv2d(X)
    return Y.reshape(Y.shape[2:])

X = nd.random.uniform(shape=(8,8))

# 注意这里是两侧分别填充 1，所以 p_w = p_h = 2。
conv2d = nn.Conv2D(1, kernel_size=3, padding=1)
comp_conv2d(conv2d, X).shape
```

当然我们可以使用有非方形核的卷积层，使用合适的填充可以同样得到同样大小是输出。

```{.python .input  n=2}
conv2d = nn.Conv2D(1, kernel_size=(5,3), padding=(2,1))
comp_conv2d(conv2d, X).shape
```

## 步幅

在上一节里我们实现的`corr2d`函数里，我们从左上元素开始计算输出，然后每次往左移一列或者往下移动一行。我们将每次移动的行数和列数称之为步幅。前面的例子里步幅在高和宽两个方向上均为1。

自然我们可以使用更大步幅。下图展示了两个方向上均使步幅为2的情况。我们高亮了计算第二个输出元素时所使用的输入元素。跟图5.2相比，这里使用的输入区域向左移了一列，从而导致输出少了一行了一列。

![同图5.2，但使用步幅2。](../img/conv_stride.svg)

一般来说，如果在高上使用步幅$s_h$，在宽上使用$s_w$，那么输出大小将是$\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor$。大致上来说，使用步幅$s$，那么输出大概会减小$s$倍。具体数字则有核大小、填充大小、和是不是能整除决定。在卷积神经网络里，我们通常来使用大于1的步幅来成倍的减小输出的高和宽。

最后我们通过一个例子来解释如何处理不能乘除的情况。

```{.python .input  n=3}
conv2d = nn.Conv2D(1, kernel_size=3, padding=1, strides=4)
comp_conv2d(conv2d, X).shape
```

这里$n_h-k_h+p_h+s_h = 8-3+2+4 = 11$，核$s_h=4$，所以输出大小为2。我们使用的输入元素如下图所示，当在横向上我们走了两步后，会发现只剩下不能被`(3, 3)`的核使用的两列。这里我们直接丢弃这两列，而不是为它们隐形的填充上0。

![使用步幅4。](../img/conv_stride2.svg)


## 小节

- 通过填充可以增加输出的高宽，常用来使得输出与输出同高宽。
- 通过步幅可以成倍的减少输出的高宽。

## 练习

- 填充和步幅使得推断输出大小变得困难。尝试使用不同的组合来观察输出大小的变化。
